{"version":3,"sources":["lib/api.ts","lib/graph.ts","CircleOfSuck.ts","App.tsx","index.tsx"],"names":["axios","Axios","create","baseURL","configure","useAPI","url","params","useAxios","data","WeightedDiGraph","size","adjMatrix","this","_","map","Array","fill","n1","n2","weight","Error","n","compact","neighbor","getHamiltonian","graph","paths","getHamiltonianFrom","curr","currPath","flatMap","allFrom","nodes","length","includes","concat","shortestPath","minBy","useCircleOfSuck","year","conference","games","useGetGames","teams","useGetTeams","useState","loading","circleOfSuck","result","setCircleOfSuck","useEffect","findCircleOfSuck","then","a","async","gameGraph","fromPairs","school","futureGames","each","conference_game","away_team","home_team","away_points","home_points","push","teamToIndex","i","losers","winner","loser","addEdge","home","away","hamiltonian","v","team1","arr","team2","from","to","isPlayed","NOW","Date","INITIAL_YEAR","getFullYear","getMonth","CircleOfSuck","isComplete","every","abbreviation","id","label","edges","width","dashes","options","height","physics","enabled","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b4b6e397.chunk.js","sourcesContent":["import Axios from 'axios'\nimport useAxios, { configure } from 'axios-hooks'\n\nimport { Conference, Game, Team } from './types'\nimport { Maybe } from './typeutils'\n\nexport const useGetTeams = (conference: Conference): Maybe<Team[]> => {\n  return useAPI<Team[]>('/teams', { conference })\n}\n\nexport const useGetGames = (year: number, conference: Conference): Maybe<Game[]> => {\n  return useAPI<Game[]>('/games', { year, conference })\n}\n\n// https://api.collegefootballdata.com/api/docs/\nconst axios = Axios.create({\n  baseURL: 'https://api.collegefootballdata.com/',\n})\n\nconfigure({ axios })\n\nexport const useAPI = <T>(url: string, params: object): Maybe<T> => {\n  const [{ data }] = useAxios({ url, params })\n  return data\n}\n","import _ from 'lodash'\n\nimport { Maybe } from './typeutils'\n\nexport class WeightedDiGraph {\n  size: number\n  adjMatrix: Maybe<number>[][]\n\n  constructor(size: number) {\n    this.size = size\n    this.adjMatrix = _.map(Array(size), () => _.fill(Array(size), null))\n  }\n\n  addEdge(n1: number, n2: number, weight: number) {\n    if (n1 >= this.size || n2 >= this.size) {\n      throw new Error('Vertex does not exist')\n    }\n    this.adjMatrix[n1][n2] = weight\n  }\n\n  allFrom(n: number): { weight: number; neighbor: number }[] {\n    if (n >= this.size) {\n      throw new Error('Vertex does not exist')\n    }\n    return _.compact(this.adjMatrix[n].map((weight, neighbor) =>\n      weight === null ? null : { weight, neighbor }\n    ))\n  }\n}\n\ntype Path = {\n  nodes: number[]\n  weight: number\n}\n\n/**\n * Get the shortest hamiltonian path of the given graph.\n */\nexport const getHamiltonian = (graph: WeightedDiGraph): Maybe<number[]> => {\n  const START_NODE = 0\n\n  const getHamiltonianFrom = (curr: number, currPath: Path): Path[] => {\n    return _.flatMap(graph.allFrom(curr), ({ neighbor, weight }) => {\n      if (neighbor === START_NODE && currPath.nodes.length === graph.size) {\n        return [currPath]\n      }\n\n      if (_.includes(currPath.nodes, neighbor)) {\n        return []\n      }\n\n      return getHamiltonianFrom(neighbor, {\n        nodes: _.concat(currPath.nodes, neighbor),\n        weight: currPath.weight + weight,\n      })\n    })\n  }\n\n  const paths = getHamiltonianFrom(START_NODE, { nodes: [START_NODE], weight: 0 })\n  const shortestPath = _.minBy(paths, 'weight')\n  if (!shortestPath) {\n    return null\n  }\n  return shortestPath.nodes\n}\n","import _ from 'lodash'\nimport { useEffect, useState } from 'react'\n\nimport { useGetGames, useGetTeams } from './lib/api'\nimport { getHamiltonian, WeightedDiGraph } from './lib/graph'\nimport { Conference, Game, Team } from './lib/types'\nimport { Maybe } from './lib/typeutils'\n\ntype CircleOfSuckResult = {\n  loading: boolean\n  circleOfSuck: Maybe<CircleOfSuckEdge[]>\n  teams: Maybe<Team[]>\n}\n\nexport const useCircleOfSuck = (year: number, conference: Conference): CircleOfSuckResult => {\n  const games = useGetGames(year, conference)\n  const teams = useGetTeams(conference)\n  const [result, setCircleOfSuck] = useState<CircleOfSuckResult>({\n    loading: true,\n    circleOfSuck: null,\n    teams: null,\n  })\n\n  useEffect(() => {\n    if (!games || !teams) {\n      return\n    }\n\n    findCircleOfSuck(teams, games).then((result) => {\n      setCircleOfSuck({\n        loading: false,\n        circleOfSuck: result,\n        teams,\n      })\n    })\n  }, [games, teams])\n\n  return result\n}\n\ntype CircleOfSuckEdge = {\n  from: Team\n  to: Team\n  isPlayed: boolean // has this game already been played?\n}\n\nconst findCircleOfSuck = async (teams: Team[], games: Game[]): Promise<Maybe<CircleOfSuckEdge[]>> => {\n  // maps winner team -> loser team\n  const gameGraph = _.fromPairs(_.map(teams, ({ school }) => [school, [] as string[]]))\n\n  // contains all future games, as [home_team, away_team] pairs\n  const futureGames = [] as [string, string][]\n\n  _.each(games, ({ conference_game, away_team, home_team, away_points, home_points }) => {\n    if (!conference_game) {\n      return\n    }\n\n    if (away_points === null || home_points === null) {\n      futureGames.push([home_team, away_team])\n    } else if (away_points > home_points) {\n      gameGraph[away_team].push(home_team)\n    } else {\n      gameGraph[home_team].push(away_team)\n    }\n  })\n\n  const teamToIndex = _.fromPairs(_.map(teams, ({ school }, i) => [school, i]))\n\n  const graph = new WeightedDiGraph(teams.length)\n  _.each(gameGraph, (losers, winner) => {\n    _.each(losers, (loser) => {\n      graph.addEdge(teamToIndex[winner], teamToIndex[loser], 0)\n    })\n  })\n  _.each(futureGames, ([home, away]) => {\n    graph.addEdge(teamToIndex[home], teamToIndex[away], 1)\n    graph.addEdge(teamToIndex[away], teamToIndex[home], 1)\n  })\n\n  const hamiltonian = getHamiltonian(graph)\n  if (!hamiltonian) {\n    return null\n  }\n\n  return _.map(hamiltonian.map((v) => teams[v]), (team1, i, arr) => {\n    const team2 = arr[i === arr.length - 1 ? 0 : i + 1]\n\n    return {\n      from: team1,\n      to: team2,\n      isPlayed: _.includes(gameGraph[team1.school], team2.school),\n    }\n  })\n}\n","import _ from 'lodash'\nimport React, { FC, useState } from 'react'\nimport Graph from 'react-graph-vis'\n\nimport { Conference } from './lib/types'\nimport { useCircleOfSuck } from './CircleOfSuck'\n\n// year should initially be the year of the last fall season\nconst NOW = new Date()\nconst INITIAL_YEAR = NOW.getFullYear() + (NOW.getMonth() < 6 ? -1 : 0)\n\nexport const App: FC = () => {\n  // TODO: make inputtable by user\n  const [year] = useState(INITIAL_YEAR)\n\n  return (\n    <main>\n      <h1>PAC-12 Circle of Suck ({year})</h1>\n      <CircleOfSuck year={year} conference=\"PAC\" />\n    </main>\n  )\n}\n\nconst CircleOfSuck: FC<{ year: number; conference: Conference }> = ({ year, conference }) => {\n  const { loading, circleOfSuck, teams } = useCircleOfSuck(year, conference)\n\n  if (loading) {\n    return <p>Loading...</p>\n  }\n\n  if (circleOfSuck === null) {\n    // TODO: show some other interesting graph\n    return <p>No possible circle of suck for this season.</p>\n  }\n\n  const isComplete = _.every(circleOfSuck, 'isPlayed')\n\n  return (\n    <>\n      {!isComplete && (\n        <p>\n          No complete circle of suck was found. Displaying a possible circle of\n          suck.\n        </p>\n      )}\n      <p>\n        An arrow from school A to school B represents a game where school A\n        beats school B.\n      </p>\n      {!isComplete && (\n        <p>\n          A dashed arrow from school A to school B represent a future game\n          that could complete the circle of suck, if school A beats school B.\n        </p>\n      )}\n      <Graph\n        graph={{\n          nodes: teams!.map(({ school, abbreviation }) => ({\n            id: school,\n            label: `${school} (${abbreviation})`,\n          })),\n          edges: circleOfSuck.map(({ from, to, isPlayed }) => {\n            return {\n              from: from.school,\n              to: to.school,\n              width: isPlayed ? 2 : 1,\n              dashes: !isPlayed,\n            }\n          })\n        }}\n        options={{\n          height: '500px',\n          physics: {\n            enabled: false,\n          },\n        }}\n      />\n    </>\n  )\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { App } from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}